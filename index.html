<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover"
    />
    <title>Tetris Mobile Fixed UI</title>
    <style>
      :root {
        --bg: #0b0f14;
        --panel: #101826;
        --text: #e6edf3;
        --muted: #94a3b8;
        --btn: #0f172a;
        --btnb: rgba(148, 163, 184, 0.26);
        --btnh: rgba(148, 163, 184, 0.55);
        --danger: #ef4444;
        --accent: #22c55e;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        background: var(--bg);
        color: var(--text);
        font-family: ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto,
          'Helvetica Neue', Arial;
        overscroll-behavior: none;
      }
      body {
        touch-action: none;
      }

      .app {
        height: 100svh;
        box-sizing: border-box;
        padding: calc(env(safe-area-inset-top) + 10px) 10px
          calc(env(safe-area-inset-bottom) + 10px) 10px;
        max-width: 560px;
        margin: 0 auto;

        display: grid;
        grid-template-rows: auto auto 1fr auto auto;
        gap: 10px;
        min-height: 0;
      }

      .topbar {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 10px;
      }
      .pills {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        align-items: center;
        font-variant-numeric: tabular-nums;
      }
      .pill {
        display: inline-flex;
        gap: 6px;
        align-items: center;
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.22);
        background: rgba(16, 24, 38, 0.38);
        color: var(--muted);
        font-size: 12px;
        white-space: nowrap;
      }
      .pill b {
        color: var(--text);
        font-weight: 700;
      }
      .pill.ok {
        color: var(--accent);
      }
      .pill.bad {
        color: var(--danger);
      }

      .miniRow {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        min-height: 0;
      }
      .miniPanel {
        background: var(--panel);
        border: 1px solid rgba(148, 163, 184, 0.18);
        border-radius: 14px;
        padding: 10px;
        box-sizing: border-box;
        min-height: 0;
      }
      .miniTitle {
        margin: 0 0 8px 0;
        font-size: 11px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: var(--muted);
      }

      /* canvasは「CSSで伸ばさない」。サイズはJSで確定する。 */
      canvas {
        display: block;
        background: #070b10;
        border: 1px solid rgba(148, 163, 184, 0.22);
        border-radius: 12px;
        box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.25);
        image-rendering: pixelated;
        touch-action: none;
      }

      .boardArea {
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 0;
      }

      .status {
        text-align: center;
        font-size: 13px;
        color: var(--muted);
        min-height: 18px;
      }
      .status.gameover {
        color: var(--danger);
        font-weight: 700;
      }
      .status.ok {
        color: var(--accent);
        font-weight: 700;
      }

      /* 下部操作：常に見える（iPhone下部セーフエリアも考慮） */
      .controls {
        position: sticky;
        bottom: calc(env(safe-area-inset-bottom) + 8px);
        background: rgba(16, 24, 38, 0.7);
        border: 1px solid rgba(148, 163, 184, 0.18);
        border-radius: 16px;
        padding: 10px;
        box-sizing: border-box;

        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .btnGrid3 {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 10px;
      }
      .btnGrid2 {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .btn {
        user-select: none;
        -webkit-user-select: none;
        text-align: center;
        background: var(--btn);
        border: 1px solid var(--btnb);
        border-radius: 14px;
        padding: 14px 10px;
        font-size: 16px;
        font-weight: 800;
        line-height: 1;
        touch-action: none;
      }
      .btn small {
        display: block;
        margin-top: 6px;
        font-size: 11px;
        font-weight: 600;
        color: var(--muted);
        line-height: 1.2;
      }
      .btn:active {
        border-color: var(--btnh);
        transform: translateY(1px);
      }
      .tinyActions {
        display: flex;
        gap: 10px;
      }
      .tinyActions button {
        flex: 1;
        background: var(--btn);
        color: var(--text);
        border: 1px solid var(--btnb);
        border-radius: 12px;
        padding: 10px 10px;
        font-size: 13px;
        font-weight: 700;
        cursor: pointer;
      }
      .tinyActions button:active {
        border-color: var(--btnh);
        transform: translateY(1px);
      }
      .hint {
        color: var(--muted);
        font-size: 11px;
        line-height: 1.45;
        text-align: center;
        opacity: 0.95;
      }

      /* PCで開いたときも破綻しない */
      @media (min-width: 900px) {
        body {
          touch-action: auto;
        }
        .app {
          max-width: 980px;
        }
      }
    </style>
  </head>

  <body>
    <div class="app">
      <div class="topbar">
        <div class="pills">
          <span class="pill">Score <b id="score">0</b></span>
          <span class="pill">Lv <b id="level">1</b></span>
          <span class="pill">Lines <b id="lines">0</b></span>
          <span class="pill">Combo <b id="combo">-</b></span>
          <span class="pill">B2B <b id="b2b">-</b></span>
          <span class="pill">Last <b id="last">-</b></span>
        </div>
        <span class="pill" id="badge">Ready</span>
      </div>

      <div class="miniRow">
        <div class="miniPanel">
          <div class="miniTitle">Hold</div>
          <canvas id="hold"></canvas>
        </div>
        <div class="miniPanel">
          <div class="miniTitle">Next</div>
          <canvas id="next"></canvas>
        </div>
      </div>

      <div class="boardArea">
        <canvas id="board"></canvas>
      </div>

      <div class="status" id="status"></div>

      <div class="controls" id="controls">
        <div class="btnGrid3">
          <div class="btn" data-act="left">←<small>Move</small></div>
          <div class="btn" data-act="rotate">⟳<small>Rotate</small></div>
          <div class="btn" data-act="right">→<small>Move</small></div>
        </div>

        <div class="btnGrid3">
          <div class="btn" data-act="down">↓<small>Soft</small></div>
          <div class="btn" data-act="hard">⤓<small>Hard</small></div>
          <div class="btn" data-act="hold">Hold<small>C</small></div>
        </div>

        <div class="btnGrid2">
          <div class="btn" data-act="pause">Pause<small>P</small></div>
          <div class="btn" data-act="restart">Restart<small>R</small></div>
        </div>

        <div class="tinyActions">
          <button id="btnMute">Mute</button>
          <button id="btnStart">Start</button>
        </div>

        <div class="hint">
          盤面ジェスチャ: タップ=回転 / 左右スワイプ=移動 / 下スワイプ=ソフト /
          上スワイプ=ハード<br />
          キーボード(任意): ←→↓ / Z,X,↑ / Space / C / P / R / M
        </div>
      </div>
    </div>

    <script>
      ;(() => {
        // ========= Core config =========
        const COLS = 10
        const ROWS = 20
        const HIDDEN = 2

        // Input tuning
        const DAS_MS = 140
        const ARR_MS = 35
        const SOFT_DROP_MS = 28
        const LOCK_DELAY_MS = 500

        function gravityMs(level) {
          return Math.max(80, 800 - (level - 1) * 55)
        }

        // ========= DOM =========
        const board = document.getElementById('board')
        const ctx = board.getContext('2d')

        const nextCanvas = document.getElementById('next')
        const nextCtx = nextCanvas.getContext('2d')

        const holdCanvas = document.getElementById('hold')
        const holdCtx = holdCanvas.getContext('2d')

        const controls = document.getElementById('controls')

        const elScore = document.getElementById('score')
        const elLevel = document.getElementById('level')
        const elLines = document.getElementById('lines')
        const elCombo = document.getElementById('combo')
        const elB2B = document.getElementById('b2b')
        const elLast = document.getElementById('last')
        const elStatus = document.getElementById('status')
        const elBadge = document.getElementById('badge')

        const btnMute = document.getElementById('btnMute')
        const btnStart = document.getElementById('btnStart')

        // Render sizing (JS-only)
        let CELL = 28
        let DPR = 1

        function setCanvasSize(canvas, cssW, cssH, context) {
          DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1))
          canvas.style.width = cssW + 'px'
          canvas.style.height = cssH + 'px'
          canvas.width = cssW * DPR
          canvas.height = cssH * DPR
          context.setTransform(DPR, 0, 0, DPR, 0, 0)
        }

        function resizeAll() {
          // compute available for board from actual layout
          const topbarH = document
            .querySelector('.topbar')
            .getBoundingClientRect().height
          const miniH = document
            .querySelector('.miniRow')
            .getBoundingClientRect().height
          const statusH = elStatus.getBoundingClientRect().height
          const controlsH = controls.getBoundingClientRect().height

          const vh = window.innerHeight
          const vw = document.documentElement.clientWidth

          const maxBoardW = Math.min(vw - 20, 560)
          const availH = Math.max(
            220,
            vh - (topbarH + miniH + statusH + controlsH + 40)
          )

          const cellW = Math.floor(maxBoardW / COLS)
          const cellH = Math.floor(availH / ROWS)

          CELL = Math.max(18, Math.min(36, Math.min(cellW, cellH)))

          const boardW = COLS * CELL
          const boardH = ROWS * CELL

          setCanvasSize(board, boardW, boardH, ctx)

          // Hold / Next sizing: make them stable (not stretchy)
          const miniPanelW = Math.floor((Math.min(vw - 20, 560) - 10) / 2)
          const holdW = miniPanelW - 20
          const nextW = miniPanelW - 20

          const miniCell = Math.max(12, Math.min(18, Math.floor(holdW / 9)))
          const holdH = miniCell * 4 + 18
          const nextH = miniCell * 10 + 30

          setCanvasSize(holdCanvas, holdW, holdH, holdCtx)
          setCanvasSize(nextCanvas, nextW, nextH, nextCtx)

          render()
        }

        window.addEventListener('resize', () =>
          requestAnimationFrame(resizeAll)
        )

        // ========= Pieces / Colors =========
        const COLORS = {
          I: '#38bdf8',
          O: '#facc15',
          T: '#a78bfa',
          S: '#22c55e',
          Z: '#ef4444',
          J: '#60a5fa',
          L: '#fb923c',
          G: 'rgba(255,255,255,.18)',
        }

        const PIECES = {
          I: [
            [
              [0, 1],
              [1, 1],
              [2, 1],
              [3, 1],
            ],
            [
              [2, 0],
              [2, 1],
              [2, 2],
              [2, 3],
            ],
            [
              [0, 2],
              [1, 2],
              [2, 2],
              [3, 2],
            ],
            [
              [1, 0],
              [1, 1],
              [1, 2],
              [1, 3],
            ],
          ],
          O: [
            [
              [1, 1],
              [2, 1],
              [1, 2],
              [2, 2],
            ],
            [
              [1, 1],
              [2, 1],
              [1, 2],
              [2, 2],
            ],
            [
              [1, 1],
              [2, 1],
              [1, 2],
              [2, 2],
            ],
            [
              [1, 1],
              [2, 1],
              [1, 2],
              [2, 2],
            ],
          ],
          T: [
            [
              [1, 1],
              [0, 2],
              [1, 2],
              [2, 2],
            ],
            [
              [1, 1],
              [1, 2],
              [2, 2],
              [1, 3],
            ],
            [
              [0, 2],
              [1, 2],
              [2, 2],
              [1, 3],
            ],
            [
              [1, 1],
              [0, 2],
              [1, 2],
              [1, 3],
            ],
          ],
          S: [
            [
              [1, 1],
              [2, 1],
              [0, 2],
              [1, 2],
            ],
            [
              [1, 1],
              [1, 2],
              [2, 2],
              [2, 3],
            ],
            [
              [1, 2],
              [2, 2],
              [0, 3],
              [1, 3],
            ],
            [
              [0, 1],
              [0, 2],
              [1, 2],
              [1, 3],
            ],
          ],
          Z: [
            [
              [0, 1],
              [1, 1],
              [1, 2],
              [2, 2],
            ],
            [
              [2, 1],
              [1, 2],
              [2, 2],
              [1, 3],
            ],
            [
              [0, 2],
              [1, 2],
              [1, 3],
              [2, 3],
            ],
            [
              [1, 1],
              [0, 2],
              [1, 2],
              [0, 3],
            ],
          ],
          J: [
            [
              [0, 1],
              [0, 2],
              [1, 2],
              [2, 2],
            ],
            [
              [1, 1],
              [2, 1],
              [1, 2],
              [1, 3],
            ],
            [
              [0, 2],
              [1, 2],
              [2, 2],
              [2, 3],
            ],
            [
              [1, 1],
              [1, 2],
              [0, 3],
              [1, 3],
            ],
          ],
          L: [
            [
              [2, 1],
              [0, 2],
              [1, 2],
              [2, 2],
            ],
            [
              [1, 1],
              [1, 2],
              [1, 3],
              [2, 3],
            ],
            [
              [0, 2],
              [1, 2],
              [2, 2],
              [0, 3],
            ],
            [
              [0, 1],
              [1, 1],
              [1, 2],
              [1, 3],
            ],
          ],
        }
        const KEYS = Object.keys(PIECES)

        // ========= SRS kick tables =========
        const JLSTZ_CW = {
          '0>1': [
            [0, 0],
            [-1, 0],
            [-1, 1],
            [0, -2],
            [-1, -2],
          ],
          '1>2': [
            [0, 0],
            [1, 0],
            [1, -1],
            [0, 2],
            [1, 2],
          ],
          '2>3': [
            [0, 0],
            [1, 0],
            [1, 1],
            [0, -2],
            [1, -2],
          ],
          '3>0': [
            [0, 0],
            [-1, 0],
            [-1, -1],
            [0, 2],
            [-1, 2],
          ],
        }
        const JLSTZ_CCW = {
          '0>3': [
            [0, 0],
            [1, 0],
            [1, 1],
            [0, -2],
            [1, -2],
          ],
          '3>2': [
            [0, 0],
            [-1, 0],
            [-1, -1],
            [0, 2],
            [-1, 2],
          ],
          '2>1': [
            [0, 0],
            [-1, 0],
            [-1, 1],
            [0, -2],
            [-1, -2],
          ],
          '1>0': [
            [0, 0],
            [1, 0],
            [1, -1],
            [0, 2],
            [1, 2],
          ],
        }
        const I_CW = {
          '0>1': [
            [0, 0],
            [-2, 0],
            [1, 0],
            [-2, -1],
            [1, 2],
          ],
          '1>2': [
            [0, 0],
            [-1, 0],
            [2, 0],
            [-1, 2],
            [2, -1],
          ],
          '2>3': [
            [0, 0],
            [2, 0],
            [-1, 0],
            [2, 1],
            [-1, -2],
          ],
          '3>0': [
            [0, 0],
            [1, 0],
            [-2, 0],
            [1, -2],
            [-2, 1],
          ],
        }
        const I_CCW = {
          '0>3': [
            [0, 0],
            [-1, 0],
            [2, 0],
            [-1, 2],
            [2, -1],
          ],
          '3>2': [
            [0, 0],
            [-2, 0],
            [1, 0],
            [-2, -1],
            [1, 2],
          ],
          '2>1': [
            [0, 0],
            [1, 0],
            [-2, 0],
            [1, -2],
            [-2, 1],
          ],
          '1>0': [
            [0, 0],
            [2, 0],
            [-1, 0],
            [2, 1],
            [-1, -2],
          ],
        }
        function invertY(list) {
          return list.map(([x, y]) => [x, -y])
        }
        for (const k in JLSTZ_CW) JLSTZ_CW[k] = invertY(JLSTZ_CW[k])
        for (const k in JLSTZ_CCW) JLSTZ_CCW[k] = invertY(JLSTZ_CCW[k])
        for (const k in I_CW) I_CW[k] = invertY(I_CW[k])
        for (const k in I_CCW) I_CCW[k] = invertY(I_CCW[k])

        function kicksFor(type, from, to, dir) {
          if (type === 'O') return [[0, 0]]
          const key = `${from}>${to}`
          const cw = dir === 1
          if (type === 'I')
            return cw ? I_CW[key] || [[0, 0]] : I_CCW[key] || [[0, 0]]
          return cw ? JLSTZ_CW[key] || [[0, 0]] : JLSTZ_CCW[key] || [[0, 0]]
        }

        // ========= 7-bag =========
        function shuffledBag() {
          const bag = [...KEYS]
          for (let i = bag.length - 1; i > 0; i--) {
            const j = (Math.random() * (i + 1)) | 0
            ;[bag[i], bag[j]] = [bag[j], bag[i]]
          }
          return bag
        }

        // ========= Audio (SFX) =========
        let audioCtx = null
        let muted = false

        function ensureAudio() {
          if (audioCtx) return
          try {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)()
          } catch (_) {
            audioCtx = null
          }
        }
        function beep(freq = 440, dur = 0.05, type = 'square', gain = 0.06) {
          if (muted || !audioCtx) return
          const t0 = audioCtx.currentTime
          const osc = audioCtx.createOscillator()
          const g = audioCtx.createGain()
          osc.type = type
          osc.frequency.setValueAtTime(freq, t0)
          g.gain.setValueAtTime(gain, t0)
          g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur)
          osc.connect(g).connect(audioCtx.destination)
          osc.start(t0)
          osc.stop(t0 + dur + 0.01)
        }
        const SFX = {
          move: () => beep(240, 0.03, 'square', 0.05),
          rotate: () => beep(420, 0.04, 'square', 0.06),
          hold: () => beep(300, 0.05, 'triangle', 0.06),
          soft: () => beep(180, 0.02, 'sine', 0.02),
          hard: () => beep(520, 0.05, 'square', 0.07),
          lock: () => beep(160, 0.05, 'triangle', 0.05),
          clear1: () => beep(620, 0.07, 'sine', 0.06),
          clear2: () => beep(660, 0.08, 'sine', 0.07),
          clear3: () => beep(720, 0.09, 'sine', 0.08),
          tetris: () => {
            beep(880, 0.1, 'square', 0.07)
            beep(660, 0.12, 'square', 0.06)
          },
          tspin: () => {
            beep(950, 0.08, 'square', 0.07)
            beep(760, 0.1, 'triangle', 0.06)
          },
          gameover: () => {
            beep(220, 0.15, 'sawtooth', 0.06)
            beep(110, 0.18, 'sawtooth', 0.05)
          },
          pc: () => {
            beep(1040, 0.12, 'square', 0.07)
            beep(1240, 0.12, 'square', 0.06)
          },
        }

        // ========= Game state =========
        let grid
        let current
        let nextQueue = []
        let bag = []
        let hold = null
        let holdUsed = false

        let score = 0
        let level = 1
        let lines = 0
        let combo = -1
        let b2b = false

        let running = false
        let paused = false
        let gameOver = false

        let lastTime = 0
        let gravAcc = 0
        let lockAcc = 0
        let lastAction = 'none' // move/rotate/drop/none

        const keyState = { left: false, right: false, down: false }
        const touchHold = { left: false, right: false, down: false }

        let moveDir = 0
        let dasAcc = 0
        let arrAcc = 0
        let dasCharged = false

        // ========= Helpers =========
        function makeGrid() {
          const h = ROWS + HIDDEN
          return Array.from({ length: h }, () => Array(COLS).fill(null))
        }
        function spawn(type) {
          return { type, rot: 0, x: 3, y: 0 }
        }
        function fillQueue() {
          while (nextQueue.length < 6) {
            if (bag.length === 0) bag = shuffledBag()
            nextQueue.push(bag.pop())
          }
        }
        function takeNext() {
          fillQueue()
          const t = nextQueue.shift()
          fillQueue()
          return t
        }
        function cellsOf(p) {
          const shape = PIECES[p.type][p.rot]
          return shape.map(([dx, dy]) => [p.x + dx, p.y + dy])
        }
        function inside(x, y) {
          return x >= 0 && x < COLS && y >= 0 && y < ROWS + HIDDEN
        }
        function collides(p) {
          for (const [x, y] of cellsOf(p)) {
            if (!inside(x, y)) return true
            if (grid[y][x]) return true
          }
          return false
        }
        function grounded(p) {
          return collides({ ...p, y: p.y + 1 })
        }
        function merge(p) {
          for (const [x, y] of cellsOf(p)) {
            if (y >= 0 && y < ROWS + HIDDEN) grid[y][x] = p.type
          }
        }
        function clearLines() {
          let cleared = 0
          for (let y = 0; y < ROWS + HIDDEN; y++) {
            if (grid[y].every((v) => v)) {
              grid.splice(y, 1)
              grid.unshift(Array(COLS).fill(null))
              cleared++
            }
          }
          return cleared
        }
        function isPerfectClear() {
          for (let y = HIDDEN; y < ROWS + HIDDEN; y++) {
            for (let x = 0; x < COLS; x++) {
              if (grid[y][x]) return false
            }
          }
          return true
        }

        // ========= Move/Rotate =========
        function tryMove(dx, dy) {
          const p = { ...current, x: current.x + dx, y: current.y + dy }
          if (!collides(p)) {
            current = p
            lastAction = 'move'
            if (grounded(current)) lockAcc = 0
            return true
          }
          return false
        }

        function tryRotate(dir) {
          const from = current.rot
          const to = (from + dir + 4) % 4
          const base = { ...current, rot: to }
          const kicks = kicksFor(current.type, from, to, dir)
          for (const [kx, ky] of kicks) {
            const p = { ...base, x: base.x + kx, y: base.y + ky }
            if (!collides(p)) {
              current = p
              lastAction = 'rotate'
              if (grounded(current)) lockAcc = 0
              SFX.rotate()
              return true
            }
          }
          return false
        }

        function hardDrop() {
          let dist = 0
          while (!collides({ ...current, y: current.y + 1 })) {
            current = { ...current, y: current.y + 1 }
            dist++
          }
          score += dist * 2
          lastAction = 'drop'
          SFX.hard()
          lockNow()
        }

        // ========= T-Spin =========
        function detectTSpin(lockedPiece) {
          if (lockedPiece.type !== 'T') return false
          if (lastAction !== 'rotate') return false

          const cx = lockedPiece.x + 1
          const cy = lockedPiece.y + 2
          const corners = [
            [cx - 1, cy - 1],
            [cx + 1, cy - 1],
            [cx - 1, cy + 1],
            [cx + 1, cy + 1],
          ]
          let filled = 0
          for (const [x, y] of corners) {
            if (!inside(x, y) || grid[y][x]) filled++
          }
          return filled >= 3
        }

        // ========= Scoring =========
        function addClearScore({ cleared, tspin }) {
          let label = '-'
          let special = false

          if (cleared > 0) {
            combo++
            if (combo > 0) score += combo * 50 * level

            let base = 0
            if (tspin) {
              special = true
              const tsp = [400, 800, 1200, 1600]
              base = tsp[cleared] ?? 0
              label = `T-Spin ${
                ['', 'Single', 'Double', 'Triple'][cleared] || ''
              }`.trim()
            } else {
              const normal = [0, 100, 300, 500, 800]
              base = normal[cleared] ?? 0
              label = cleared === 4 ? 'Tetris' : `${cleared} lines`
              if (cleared === 4) special = true
            }

            if (special) {
              if (b2b) base = Math.floor(base * 1.5)
              b2b = true
            } else {
              b2b = false
            }

            score += base * level
            lines += cleared
          } else {
            combo = -1
            if (tspin) {
              score += 400 * level
              label = 'T-Spin'
            }
          }

          if (cleared > 0 && isPerfectClear()) {
            score += 2000 * level
            label = 'Perfect Clear'
            SFX.pc()
          }

          const newLevel = 1 + Math.floor(lines / 10)
          if (newLevel !== level) level = newLevel

          if (cleared === 1) SFX.clear1()
          if (cleared === 2) SFX.clear2()
          if (cleared === 3) SFX.clear3()
          if (cleared === 4) SFX.tetris()
          if (tspin && cleared > 0) SFX.tspin()

          elLast.textContent = label
        }

        // ========= Lock/Hold =========
        function lockNow() {
          merge(current)
          const tspin = detectTSpin(current)
          const cleared = clearLines()
          addClearScore({ cleared, tspin })

          holdUsed = false
          lockAcc = 0
          lastAction = 'none'

          current = spawn(takeNext())
          if (collides(current)) {
            running = false
            gameOver = true
            setBadge('Game Over', true)
            setStatus('Game Over. Restartで再開できます。', 'gameover')
            SFX.gameover()
          } else {
            SFX.lock()
          }
        }

        function doHold() {
          if (!running || paused || gameOver) return
          if (holdUsed) return

          holdUsed = true
          const cur = current.type
          if (hold === null) {
            hold = cur
            current = spawn(takeNext())
          } else {
            current = spawn(hold)
            hold = cur
          }
          lockAcc = 0
          lastAction = 'none'
          SFX.hold()

          if (collides(current)) {
            running = false
            gameOver = true
            setBadge('Game Over', true)
            setStatus('Game Over（ホールド後に配置不可）', 'gameover')
            SFX.gameover()
          }
        }

        function ghostOf(p) {
          const g = { ...p }
          while (!collides({ ...g, y: g.y + 1 })) g.y++
          return g
        }

        // ========= Render =========
        function drawGridLines() {
          ctx.strokeStyle = 'rgba(148,163,184,.10)'
          ctx.lineWidth = 1
          for (let x = 1; x < COLS; x++) {
            ctx.beginPath()
            ctx.moveTo(x * CELL + 0.5, 0)
            ctx.lineTo(x * CELL + 0.5, ROWS * CELL)
            ctx.stroke()
          }
          for (let y = 1; y < ROWS; y++) {
            ctx.beginPath()
            ctx.moveTo(0, y * CELL + 0.5)
            ctx.lineTo(COLS * CELL, y * CELL + 0.5)
            ctx.stroke()
          }
        }

        function drawCell(c, x, y, color, alpha = 1) {
          const vy = y - HIDDEN
          if (vy < 0) return
          const px = x * CELL
          const py = vy * CELL
          c.globalAlpha = alpha
          c.fillStyle = color
          c.fillRect(px + 1, py + 1, CELL - 2, CELL - 2)
          c.globalAlpha = alpha * 0.35
          c.fillStyle = '#ffffff'
          c.fillRect(px + 2, py + 2, Math.max(0, CELL - 4), 3)
          c.globalAlpha = 1
        }

        function drawMiniPiece(c, type, ox, oy, cell) {
          const shape = PIECES[type][0]
          const xs = shape.map((p) => p[0])
          const ys = shape.map((p) => p[1])
          const minX = Math.min(...xs)
          const minY = Math.min(...ys)

          for (const [dx, dy] of shape) {
            const x = dx - minX
            const y = dy - minY
            c.fillStyle = COLORS[type]
            c.fillRect(ox + x * cell, oy + y * cell, cell - 2, cell - 2)
            c.globalAlpha = 0.35
            c.fillStyle = '#ffffff'
            c.fillRect(
              ox + x * cell + 1,
              oy + y * cell + 1,
              Math.max(0, cell - 4),
              3
            )
            c.globalAlpha = 1
          }
        }

        function renderHold() {
          const w = holdCanvas.width / DPR
          const h = holdCanvas.height / DPR
          holdCtx.clearRect(0, 0, w, h)
          if (!hold) return
          const cell = Math.max(12, Math.min(18, Math.floor(w / 9)))
          drawMiniPiece(holdCtx, hold, 10, 10, cell)
        }

        function renderNext() {
          const w = nextCanvas.width / DPR
          const h = nextCanvas.height / DPR
          nextCtx.clearRect(0, 0, w, h)
          const cell = Math.max(11, Math.min(16, Math.floor(w / 9)))
          const list = nextQueue.slice(0, 5)
          list.forEach((t, i) => {
            drawMiniPiece(nextCtx, t, 10, 10 + i * (cell * 2 + 10), cell)
          })
        }

        function render() {
          const bw = board.width / DPR
          const bh = board.height / DPR
          ctx.clearRect(0, 0, bw, bh)
          drawGridLines()

          for (let y = HIDDEN; y < ROWS + HIDDEN; y++) {
            for (let x = 0; x < COLS; x++) {
              const v = grid[y][x]
              if (v) drawCell(ctx, x, y, COLORS[v], 1)
            }
          }

          if (running && !gameOver) {
            const g = ghostOf(current)
            for (const [x, y] of cellsOf(g)) drawCell(ctx, x, y, COLORS.G, 0.35)
            for (const [x, y] of cellsOf(current))
              drawCell(ctx, x, y, COLORS[current.type], 1)
          }

          renderHold()
          renderNext()

          elScore.textContent = String(score)
          elLevel.textContent = String(level)
          elLines.textContent = String(lines)
          elCombo.textContent = combo >= 0 ? String(combo) : '-'
          elB2B.textContent = b2b ? 'ON' : '-'
        }

        // ========= UI =========
        function setStatus(text, kind) {
          elStatus.textContent = text || ''
          elStatus.className = 'status' + (kind ? ' ' + kind : '')
        }
        function setBadge(text, bad = false) {
          elBadge.textContent = text
          elBadge.className =
            'pill' + (bad ? ' bad' : text === 'Running' ? ' ok' : '')
        }

        // ========= Input repeat =========
        function updateMoveDir() {
          const l = keyState.left || touchHold.left
          const r = keyState.right || touchHold.right
          if (l && !r) return -1
          if (r && !l) return 1
          return 0
        }
        function beginHorizontal(dir) {
          if (dir === 0) return
          moveDir = dir
          dasAcc = 0
          arrAcc = 0
          dasCharged = false

          if (running && !paused && !gameOver) {
            if (tryMove(dir, 0)) SFX.move()
            render()
          }
        }

        // ========= Keyboard =========
        function handleKeyDown(e) {
          ensureAudio()
          if (audioCtx && audioCtx.state === 'suspended')
            audioCtx.resume().catch(() => {})

          const code = e.code
          if (
            [
              'ArrowLeft',
              'ArrowRight',
              'ArrowDown',
              'ArrowUp',
              'Space',
            ].includes(code)
          )
            e.preventDefault()

          if (code === 'KeyM') {
            toggleMute()
            return
          }
          if (code === 'KeyR') {
            restart()
            return
          }
          if (code === 'KeyP') {
            togglePause()
            return
          }
          if (
            code === 'KeyC' ||
            code === 'ShiftLeft' ||
            code === 'ShiftRight'
          ) {
            doHold()
            render()
            return
          }

          if (!running || paused || gameOver) return

          if (code === 'ArrowUp' || code === 'KeyX') {
            tryRotate(1)
            render()
            return
          }
          if (code === 'KeyZ') {
            tryRotate(-1)
            render()
            return
          }
          if (code === 'Space') {
            hardDrop()
            render()
            return
          }

          if (code === 'ArrowDown') {
            keyState.down = true
            SFX.soft()
            return
          }

          if (code === 'ArrowLeft' && !keyState.left) {
            keyState.left = true
            beginHorizontal(updateMoveDir())
            return
          }
          if (code === 'ArrowRight' && !keyState.right) {
            keyState.right = true
            beginHorizontal(updateMoveDir())
            return
          }
        }
        function handleKeyUp(e) {
          const code = e.code
          if (code === 'ArrowDown') {
            keyState.down = false
            return
          }
          if (code === 'ArrowLeft') keyState.left = false
          if (code === 'ArrowRight') keyState.right = false

          const dir = updateMoveDir()
          if (dir !== moveDir) {
            moveDir = dir
            dasAcc = 0
            arrAcc = 0
            dasCharged = false
            if (dir !== 0) beginHorizontal(dir)
          }
        }
        window.addEventListener('keydown', handleKeyDown, { passive: false })
        window.addEventListener('keyup', handleKeyUp)

        // ========= Touch buttons =========
        function bindButtons() {
          const buttons = [...document.querySelectorAll('.btn[data-act]')]

          function setHold(act, v) {
            if (act === 'left') touchHold.left = v
            if (act === 'right') touchHold.right = v
            if (act === 'down') touchHold.down = v

            const dir = updateMoveDir()
            if (dir !== moveDir) beginHorizontal(dir)
          }

          buttons.forEach((btn) => {
            const act = btn.dataset.act

            const onDown = (ev) => {
              ev.preventDefault()
              ensureAudio()
              if (audioCtx && audioCtx.state === 'suspended')
                audioCtx.resume().catch(() => {})

              if (act === 'left' || act === 'right' || act === 'down') {
                setHold(act, true)
                if (act === 'down') SFX.soft()
                return
              }
              if (act === 'rotate') {
                if (running && !paused && !gameOver) tryRotate(1)
                render()
                return
              }
              if (act === 'hard') {
                if (running && !paused && !gameOver) hardDrop()
                render()
                return
              }
              if (act === 'hold') {
                doHold()
                render()
                return
              }
              if (act === 'pause') {
                togglePause()
                return
              }
              if (act === 'restart') {
                restart()
                return
              }
            }
            const onUp = (ev) => {
              ev.preventDefault()
              if (act === 'left' || act === 'right' || act === 'down') {
                setHold(act, false)
              }
            }

            btn.addEventListener('pointerdown', onDown, { passive: false })
            btn.addEventListener('pointerup', onUp, { passive: false })
            btn.addEventListener('pointercancel', onUp, { passive: false })
            btn.addEventListener('pointerleave', onUp, { passive: false })
          })
        }
        bindButtons()

        // ========= Swipe on board =========
        let pointerActive = false
        let pStart = null
        let pLastX = 0

        board.addEventListener(
          'pointerdown',
          (ev) => {
            ev.preventDefault()
            ensureAudio()
            if (audioCtx && audioCtx.state === 'suspended')
              audioCtx.resume().catch(() => {})
            pointerActive = true
            pStart = { x: ev.clientX, y: ev.clientY, t: performance.now() }
            pLastX = ev.clientX
            board.setPointerCapture(ev.pointerId)
          },
          { passive: false }
        )

        board.addEventListener(
          'pointermove',
          (ev) => {
            if (!pointerActive) return
            ev.preventDefault()
            if (!running || paused || gameOver) return

            const dxStep = ev.clientX - pLastX
            const dyAll = ev.clientY - pStart.y

            const step = 22
            if (dxStep > step) {
              if (tryMove(1, 0)) SFX.move()
              pLastX = ev.clientX
              render()
            }
            if (dxStep < -step) {
              if (tryMove(-1, 0)) SFX.move()
              pLastX = ev.clientX
              render()
            }

            touchHold.down = dyAll > 24

            if (dyAll < -60) {
              touchHold.down = false
              hardDrop()
              pointerActive = false
              render()
            }
          },
          { passive: false }
        )

        board.addEventListener(
          'pointerup',
          (ev) => {
            if (!pointerActive) return
            ev.preventDefault()

            const dt = performance.now() - pStart.t
            const dx = ev.clientX - pStart.x
            const dy = ev.clientY - pStart.y

            const isTap = Math.abs(dx) < 10 && Math.abs(dy) < 10 && dt < 220
            touchHold.down = false

            if (isTap && running && !paused && !gameOver) {
              tryRotate(1)
              render()
            }
            pointerActive = false
          },
          { passive: false }
        )

        board.addEventListener('pointercancel', () => {
          pointerActive = false
          touchHold.down = false
        })

        // ========= Mute/Start =========
        function toggleMute() {
          muted = !muted
          btnMute.textContent = muted ? 'Unmute' : 'Mute'
        }
        btnMute.addEventListener('click', () => toggleMute())
        btnStart.addEventListener('click', () => start())

        // ========= Loop =========
        function tick(time) {
          render()

          if (!running || paused || gameOver) {
            requestAnimationFrame(tick)
            return
          }

          const dt = time - lastTime
          lastTime = time

          // horizontal (DAS/ARR)
          const desiredDir = updateMoveDir()
          if (desiredDir !== moveDir) {
            moveDir = desiredDir
            dasAcc = 0
            arrAcc = 0
            dasCharged = false
            if (moveDir !== 0) beginHorizontal(moveDir)
          } else if (moveDir !== 0) {
            dasAcc += dt
            if (!dasCharged) {
              if (dasAcc >= DAS_MS) {
                dasCharged = true
                arrAcc = 0
              }
            } else {
              arrAcc += dt
              while (arrAcc >= ARR_MS) {
                arrAcc -= ARR_MS
                if (tryMove(moveDir, 0)) SFX.move()
                else break
              }
            }
          }

          // gravity / soft
          const soft = keyState.down || touchHold.down
          const interval = soft ? SOFT_DROP_MS : gravityMs(level)
          gravAcc += dt

          while (gravAcc >= interval) {
            gravAcc -= interval
            const movedDown = tryMove(0, 1)
            if (movedDown) {
              if (soft) score += 1
            } else {
              break
            }
          }

          // lock delay
          if (grounded(current)) {
            lockAcc += dt
            if (lockAcc >= LOCK_DELAY_MS) lockNow()
          } else {
            lockAcc = 0
          }

          requestAnimationFrame(tick)
        }

        // ========= Control flow =========
        function start() {
          ensureAudio()
          if (audioCtx && audioCtx.state === 'suspended')
            audioCtx.resume().catch(() => {})

          if (gameOver) restart()
          if (!running) {
            running = true
            paused = false
            setBadge('Running', false)
            setStatus('')
            lastTime = performance.now()
          }
        }

        function togglePause() {
          if (gameOver) return
          if (!running) {
            start()
            return
          }
          paused = !paused
          setBadge(paused ? 'Paused' : 'Running', false)
          setStatus(paused ? 'Paused' : '')
          if (!paused) lastTime = performance.now()
        }

        function restart() {
          grid = makeGrid()
          nextQueue = []
          bag = []
          hold = null
          holdUsed = false

          score = 0
          level = 1
          lines = 0
          combo = -1
          b2b = false

          running = true
          paused = false
          gameOver = false
          gravAcc = 0
          lockAcc = 0
          lastAction = 'none'

          keyState.left = keyState.right = keyState.down = false
          touchHold.left = touchHold.right = touchHold.down = false
          moveDir = 0
          dasAcc = 0
          arrAcc = 0
          dasCharged = false

          fillQueue()
          current = spawn(takeNext())

          setBadge('Running', false)
          setStatus('')
          elLast.textContent = '-'
          lastTime = performance.now()
          render()
        }

        // ========= Init =========
        function init() {
          grid = makeGrid()
          nextQueue = []
          bag = shuffledBag()
          fillQueue()
          current = spawn(takeNext())

          score = 0
          level = 1
          lines = 0
          combo = -1
          b2b = false

          running = false
          paused = false
          gameOver = false

          setBadge('Ready', false)
          setStatus('Startで開始できます。')
          btnMute.textContent = 'Mute'

          // layout stable -> resize then start RAF
          requestAnimationFrame(() => {
            resizeAll()
            lastTime = performance.now()
            requestAnimationFrame(tick)
          })
        }

        init()
      })()
    </script>
  </body>
</html>
